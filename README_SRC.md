# Extended Kalman Filter Project
Self-Driving Car Engineer Nanodegree Program

## Introduction

For safety reasons, it is important for a self-driving vehicle to estimate and predict the states of nearby moving objects. To this aim, most of self-driving cars are equipped with cameras, lidars and radars to obtain real time data. In this project, we discuss methods that can be used to improve the accuracy of estimation on states of nearby moving objects, when only lidar and radar measurements were used. 

[//]: # (Image References)
[image1]: ./pictures/EKF_fig3.png
[image2]: ./pictures/EKF_fig4.png
[image3]: ./pictures/EKF_fig1.png
[image4]: ./pictures/EKF_fig2.png
[image5]: ./pictures/ProcessingFlow.png
[image6]: ./pictures/main_fig.png
[image7]: ./pictures/FusionEKF_fig.png
[image8]: ./pictures/kalman_filter_fig.png

Further, assume the data used here is the preprocessed data from lidar sensors or radar sensors. As we knew, these data are with noisy, which cannot be directly used as estimation or prediction of moving objects. Refer to the following figure to get an intuitive feeling. 

![alt text][image1]

Here, lidar measurements are red circles, radar measurements are blue circles with an arrow pointing in the direction of the observed angle. As we can see, they follow randoom distributions, which could cause large errors with certain possibility in an estimation. In this project, we will lower down the uncertainty of prediction by considering also the law of motions. The method we are going to use is Kalman Filter. See below links for more documents on EKF (Thanks to my reviewer):

  [EKF Tutorial](http://home.wlu.edu/~levys/kalman_tutorial/)

  [Understanding and Applying Kalman Filtering](http://biorobotics.ri.cmu.edu/papers/sbp_papers/integrated3/kleeman_kalman_basics.pdf)

The following figure shows an improved real time estimation after Extended Kalman Filter. Here, the estimation markers are green triangles.

![alt_text][image2]

## EKF Algorithm - Overview

Suppose we are going to estimate the state of a moving pedestrain or a bicycle, whose state is represented by a 2D position and a 2D velocity, $x=(px,py,vx,vy)$. Each time we receive a new measurements from a given sensor, the estimation function process measurement is triggered. At the first iteration, we initialize the state and covariance matrix. Subsequently, the prediction and measurement update are called. With more detail, we have to compute the elapsed time between the current and previous observation before every prediction. Based on this elapsed time, we then calculate new state transition and process covariance matrices. The measurement update step depends on sensor type. If the current observations come from a radar sensor, we first compute the new Jacobian Hj using the non-linear measurement function. Then set up radar matrices and call the measurement update. Otherwise, if the current observation is generated by a laser sensor, then we just set up the Extended Kalman Filter with the laser H and R matrices and followed with the measurement update.

The following is the overall processing flow.

![alt_text][image5]

## EKF Algorithm - Structure

### main.cpp

The main function responsible for reading in the data file and the communication between simulator and itself. The main.cpp reads in the sensor data line by line from the client and stores the data into a measurement object that it passes to the Kalman filter for processing. Also a ground truth list and an estimation list are used for tracking RMSE.


![alt_text][image6]

### FusionEKF.cpp

The function FusionEKF initializes the filter, calls the predict function and calls the update function.

![alt_text][image7]

### kalman_filter.cpp

The function kalman_filter defines the predict function, the update function for lidar, and the update function for radar

![alt_text][image8]

### tools.cpp

The function tools calculate RMSE, Jacobian matrix, responsible for coordinate transformation between the Cartesian and the polar coordinates and define almost zero value epsilon.

## Results

The following pictures show the application our algorithm on Dataset 1 and Dataset 2 of the simulator.

![alt_text][image3]

![alt_text][image5]


